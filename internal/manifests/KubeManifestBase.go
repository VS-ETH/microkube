/*
 * Copyright 2018 The microkube authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package manifests

import (
	"bytes"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	"github.com/uubk/microkube/pkg/handlers"
	"io/ioutil"
	appsv1 "k8s.io/api/apps/v1"
	extensionsv1beta1 "k8s.io/api/extensions/v1beta1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/tools/clientcmd"
	cmd2 "k8s.io/kubernetes/pkg/kubectl/cmd"
	"os"
)

// KubeManifestRuntimeInfo contains all runtime information about the current environment (e.g. pod IP range...)
type KubeManifestRuntimeInfo struct {
	ExecEnv handlers.ExecutionEnvironment
}

// KubeManifestBase is the base type for all autogenerated manifests, bundling common functionality
type KubeManifestBase struct {
	// List of objects to create
	objects []string
	// Object to use for health check, if applicable
	healthObj string
	// Kubernetes client set for interacting with the real API
	client kubernetes.Interface
	// Same as 'healthObj', but parsed
	healthObjParsed runtime.Object
	// Name of this service
	name string
}

// KubeManifest is implemented by all types that can be applied to a kube cluster as supported by KubeManifestBase
type KubeManifest interface {
	// ApplyToCluster applies this manifest to the kubernetes cluster specified in 'kubeconfig'
	ApplyToCluster(kubeconfig string) error
	// IsHealthy checks whether the resources this manifest describes can be considered 'healthy'
	// You'll need to run InitHealthCheck first.
	IsHealthy() (bool, error)
	// InitHealthCheck prepares this object for health checks
	InitHealthCheck(kubeconfig string) error
	// Name returns the name of this object's service
	Name() string
}

type KubeManifestConstructor func(KubeManifestRuntimeInfo) (KubeManifest, error)

// Register registers the manifest 'manifest' (JSON string) with this instance of KubeManifestBase. It is supposed to
// be only used by derived types!
func (m *KubeManifestBase) Register(manifest string) {
	m.objects = append(m.objects, manifest)
}

// RegisterHO registers the manifest 'manifest' (JSON string) as something to watch for a healthcheck with this instance
// of KubeManifestBase. It is supposed to be only used by derived types! Note that if you also want to create that
// object, you also need to call 'Register'. Only the last object registered will be considered.
func (m *KubeManifestBase) RegisterHO(manifest string) {
	m.healthObj = manifest
}

// Name returns  the name of this object's service
func (m *KubeManifestBase) Name() string {
	return m.name
}

// Set name sets the name of this object's service and is only supposed to be used by derived types!
func (m *KubeManifestBase) SetName(name string) {
	m.name = name
}

// ApplyToCluster applies this manifest to the kubernetes cluster specified in 'kubeconfig'
func (m *KubeManifestBase) ApplyToCluster(kubeconfig string) error {
	file, err := ioutil.TempFile("", "kube-apply-manifest")
	if err != nil {
		file.Close()
		return err
	}

	for _, obj := range m.objects {
		for pos := 0; pos < len(obj); {
			n, err := file.Write([]byte(obj))
			if err != nil {
				panic(err)
			}
			pos += n
		}
	}

	file.Close()

	// This is exceedingly important: If you don't do this, the client config merge will not work correctly and always
	// overwrite your server url with localhost:8080.
	clientcmd.ClusterDefaults.Server = ""

	// TODO(uubk): Find a nicer way to do this
	// Invoking kubectl apply is probably the most future-proof way to do this, but it's also blowing up 4KB of YAML
	// to around 50 MB of binary when generating one...
	buf := bytes.Buffer{}
	cmd := cmd2.NewKubectlCommand(nil, &buf, os.Stderr)
	args := []string{
		"--kubeconfig=" + kubeconfig,
		"apply",
		"-f",
		file.Name(),
	}
	cmd.SetArgs(args)

	return cmd.Execute()
}

// IsHealthy checks whether the resources this manifest describes can be considered 'healthy'
// You'll need to run InitHealthCheck first.
func (m *KubeManifestBase) IsHealthy() (bool, error) {
	if m.client == nil {
		panic("run InitHealthCheck first")
	}

	// Deployment, v1
	if deployment, ok := m.healthObjParsed.(*appsv1.Deployment); ok {
		realDep, err := m.client.AppsV1().Deployments(deployment.Namespace).Get(deployment.Name, metav1.GetOptions{})
		if err != nil {
			return false, err
		}
		if realDep == nil {
			return false, nil
		}
		log.WithFields(log.Fields{
			"component":           "services",
			"service":             m.name,
			"replicasReady":       realDep.Status.ReadyReplicas,
			"replicasTotal":       realDep.Status.Replicas,
			"replicasAvailable":   realDep.Status.AvailableReplicas,
			"replicasUnavailable": realDep.Status.UnavailableReplicas,
			"replicasUpdated":     realDep.Status.UpdatedReplicas,
		}).Debug("Deployment status")
		if realDep.Status.Replicas > realDep.Status.ReadyReplicas {
			return false, nil
		} else {
			return true, nil
		}
	}
	// Deployment, v1beta1
	if deployment, ok := m.healthObjParsed.(*extensionsv1beta1.Deployment); ok {
		realDep, err := m.client.AppsV1beta1().Deployments(deployment.Namespace).Get(deployment.Name, metav1.GetOptions{})
		if err != nil {
			return false, err
		}
		if realDep == nil {
			return false, nil
		}
		log.WithFields(log.Fields{
			"component":           "services",
			"service":             m.name,
			"replicasReady":       realDep.Status.ReadyReplicas,
			"replicasTotal":       realDep.Status.Replicas,
			"replicasAvailable":   realDep.Status.AvailableReplicas,
			"replicasUnavailable": realDep.Status.UnavailableReplicas,
			"replicasUpdated":     realDep.Status.UpdatedReplicas,
		}).Debug("Deployment status")
		if realDep.Status.Replicas > realDep.Status.ReadyReplicas {
			return false, nil
		} else {
			return true, nil
		}
	}

	return false, nil
}

// InitHealthCheck prepares this object for health checks
func (m *KubeManifestBase) InitHealthCheck(kubeconfig string) error {
	// Check whether this will work at all
	if m.healthObj == "" {
		return errors.New("no health manifest registered")
	}

	// Init kube client
	config, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
	if err != nil {
		return err
	}
	m.client, err = kubernetes.NewForConfig(config)
	if err != nil {
		return err
	}

	// Decode object into Kubernetes object
	decodeFun := scheme.Codecs.UniversalDeserializer().Decode
	m.healthObjParsed, _, err = decodeFun([]byte(m.healthObj), nil, nil)
	if err != nil {
		return err
	}
	return nil
}
